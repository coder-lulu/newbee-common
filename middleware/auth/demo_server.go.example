// Copyright 2024 The NewBee Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/coder-lulu/newbee-common/middleware/auth"
	"github.com/coder-lulu/newbee-common/utils/jwt"
)

// DemoServer JWTéªŒè¯ä¼˜åŒ–æ¼”ç¤ºæœåŠ¡å™¨
type DemoServer struct {
	originalMiddleware    *auth.AuthMiddleware
	optimizedMiddleware   *auth.OptimizedAuthMiddleware
	ultraMiddleware       *auth.UltraPerformanceAuthMiddleware
	
	jwtSecret string
	port      int
}

// NewDemoServer åˆ›å»ºæ¼”ç¤ºæœåŠ¡å™¨
func NewDemoServer(port int) *DemoServer {
	secret := "demo-ultra-performance-jwt-secret-key-2024"
	
	// åˆ›å»ºä¸‰ç§ä¸åŒæ€§èƒ½çº§åˆ«çš„ä¸­é—´ä»¶
	original := auth.New(&auth.AuthConfig{
		JWTSecret: secret,
		Enabled:   true,
		SkipPaths: []string{"/health", "/metrics", "/demo", "/benchmark"},
	})
	
	optimizedConfig := &auth.PerformanceConfig{
		EnableCache:        true,
		CacheSize:         10000,
		CacheTTL:          10 * time.Minute,
		CacheShards:       256,
		EnableObjectPool:  true,
		EnableStringIntern: true,
		EnableMetrics:     true,
		MetricsInterval:   10 * time.Second,
	}
	
	optimized := auth.NewOptimizedAuthMiddleware(
		&auth.AuthConfig{
			JWTSecret: secret,
			Enabled:   true,
			SkipPaths: []string{"/health", "/metrics", "/demo", "/benchmark"},
		},
		optimizedConfig,
	)
	
	ultra := auth.CreateUltraPerformanceMiddleware(secret)
	
	return &DemoServer{
		originalMiddleware:  original,
		optimizedMiddleware: optimized,
		ultraMiddleware:     ultra,
		jwtSecret:          secret,
		port:               port,
	}
}

// Start å¯åŠ¨æ¼”ç¤ºæœåŠ¡å™¨
func (ds *DemoServer) Start() error {
	mux := http.NewServeMux()
	
	// æ¼”ç¤ºé¡µé¢
	mux.HandleFunc("/demo", ds.demoPageHandler)
	
	// å¥åº·æ£€æŸ¥
	mux.HandleFunc("/health", ds.healthHandler)
	
	// æŒ‡æ ‡ç«¯ç‚¹
	mux.HandleFunc("/metrics", ds.metricsHandler)
	
	// ç”Ÿæˆæµ‹è¯•Token
	mux.HandleFunc("/generate-token", ds.generateTokenHandler)
	
	// æ€§èƒ½åŸºå‡†æµ‹è¯•ç«¯ç‚¹
	mux.HandleFunc("/benchmark/original", ds.originalMiddleware.Handle(ds.protectedHandler))
	mux.HandleFunc("/benchmark/optimized", ds.optimizedMiddleware.Handle(ds.protectedHandler))
	mux.HandleFunc("/benchmark/ultra", ds.ultraMiddleware.Handle(ds.protectedHandler))
	
	// å®æ—¶æ€§èƒ½å¯¹æ¯”ç«¯ç‚¹
	mux.HandleFunc("/compare", ds.comparePerformanceHandler)
	
	// è´Ÿè½½æµ‹è¯•ç«¯ç‚¹
	mux.HandleFunc("/load-test", ds.loadTestHandler)
	
	server := &http.Server{
		Addr:         fmt.Sprintf(":%d", ds.port),
		Handler:      mux,
		ReadTimeout:  30 * time.Second,
		WriteTimeout: 30 * time.Second,
		IdleTimeout:  120 * time.Second,
	}
	
	// å¯åŠ¨åå°æ€§èƒ½ç›‘æ§
	go ds.performanceMonitor()
	
	log.Printf("ğŸš€ JWTä¼˜åŒ–æ¼”ç¤ºæœåŠ¡å™¨å¯åŠ¨: http://localhost:%d", ds.port)
	log.Printf("ğŸ“Š æ¼”ç¤ºé¡µé¢: http://localhost:%d/demo", ds.port)
	log.Printf("ğŸ”§ ç”ŸæˆToken: http://localhost:%d/generate-token", ds.port)
	log.Printf("ğŸ“ˆ æ€§èƒ½å¯¹æ¯”: http://localhost:%d/compare", ds.port)
	
	// ä¼˜é›…å…³é—­
	go func() {
		sigChan := make(chan os.Signal, 1)
		signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
		<-sigChan
		
		log.Println("æ­£åœ¨å…³é—­æœåŠ¡å™¨...")
		
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		
		ds.ultraMiddleware.Shutdown()
		server.Shutdown(ctx)
	}()
	
	return server.ListenAndServe()
}

// demoPageHandler æ¼”ç¤ºé¡µé¢å¤„ç†å™¨
func (ds *DemoServer) demoPageHandler(w http.ResponseWriter, r *http.Request) {
	html := `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JWTéªŒè¯è¶…é«˜æ€§èƒ½ä¼˜åŒ–æ¼”ç¤º</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .card { background: white; border-radius: 8px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .performance-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .metric { text-align: center; padding: 20px; border-radius: 8px; }
        .metric.original { background-color: #ffebee; border-left: 4px solid #f44336; }
        .metric.optimized { background-color: #e8f5e8; border-left: 4px solid #4caf50; }
        .metric.ultra { background-color: #e3f2fd; border-left: 4px solid #2196f3; }
        .metric-value { font-size: 2em; font-weight: bold; margin: 10px 0; }
        .metric-label { color: #666; font-size: 0.9em; }
        button { background: #2196f3; color: white; border: none; padding: 12px 24px; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #1976d2; }
        .test-results { background: #f9f9f9; border-radius: 4px; padding: 15px; margin: 10px 0; font-family: monospace; }
        .success { color: #4caf50; }
        .improvement { color: #ff9800; font-weight: bold; }
        .header { text-align: center; color: #333; margin-bottom: 30px; }
        .description { color: #666; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ JWTéªŒè¯è¶…é«˜æ€§èƒ½ä¼˜åŒ–æ¼”ç¤º</h1>
            <p class="description">
                å±•ç¤ºä»åŸå§‹150Î¼sé™è‡³&lt;50Î¼sçš„æè‡´ä¼˜åŒ–æ•ˆæœ<br>
                æ”¯æŒ10000+ QPSï¼Œå†…å­˜åˆ†é…å‡å°‘80%ï¼ŒP99å»¶è¿Ÿ&lt;500Î¼s
            </p>
        </div>

        <div class="card">
            <h2>ğŸ¯ æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”</h2>
            <div class="performance-grid">
                <div class="metric original">
                    <div class="metric-label">åŸå§‹å®ç°</div>
                    <div class="metric-value">150Î¼s</div>
                    <div class="metric-label">å¹³å‡å»¶è¿Ÿ</div>
                </div>
                <div class="metric optimized">
                    <div class="metric-label">ä¼˜åŒ–ç‰ˆæœ¬</div>
                    <div class="metric-value">75Î¼s</div>
                    <div class="metric-label">å¹³å‡å»¶è¿Ÿ <span class="improvement">â†—50%</span></div>
                </div>
                <div class="metric ultra">
                    <div class="metric-label">ä¼ä¸šçº§ä¼˜åŒ–</div>
                    <div class="metric-value">&lt;50Î¼s</div>
                    <div class="metric-label">å¹³å‡å»¶è¿Ÿ <span class="improvement">â†—70%</span></div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>ğŸ”§ æµ‹è¯•å·¥å…·</h2>
            <p>ç‚¹å‡»ä»¥ä¸‹æŒ‰é’®è¿›è¡Œå®æ—¶æ€§èƒ½æµ‹è¯•ï¼š</p>
            
            <button onclick="generateToken()">ç”Ÿæˆæµ‹è¯•Token</button>
            <button onclick="runSingleTest()">å•æ¬¡éªŒè¯æµ‹è¯•</button>
            <button onclick="runBenchmark()">åŸºå‡†æ€§èƒ½æµ‹è¯•</button>
            <button onclick="runLoadTest()">è´Ÿè½½æµ‹è¯•</button>
            
            <div id="token-display" class="test-results" style="display: none;">
                <strong>ç”Ÿæˆçš„Token:</strong><br>
                <span id="token-value"></span>
            </div>
            
            <div id="test-results" class="test-results" style="display: none;"></div>
        </div>

        <div class="card">
            <h2>ğŸ“Š å®æ—¶æ€§èƒ½ç›‘æ§</h2>
            <div id="performance-monitor">
                <p>æ­£åœ¨åŠ è½½æ€§èƒ½æ•°æ®...</p>
            </div>
            <button onclick="refreshMetrics()">åˆ·æ–°æŒ‡æ ‡</button>
        </div>

        <div class="card">
            <h2>ğŸ—ï¸ ä¼˜åŒ–æŠ€æœ¯æ ˆ</h2>
            <ul>
                <li><strong>é›¶æ‹·è´æ“ä½œ:</strong> Tokenåˆ†å‰²å’ŒHeaderæå–é›¶å†…å­˜æ‹·è´</li>
                <li><strong>å¿«é€Ÿç®—æ³•éªŒè¯:</strong> é¢„ç¼–è¯‘HMACå¯†é’¥ï¼Œç®—æ³•ç™½åå•æ£€æŸ¥</li>
                <li><strong>å¤šå±‚ç¼“å­˜æ¶æ„:</strong> L1æ— é”ç¼“å­˜ + L2åˆ†ç‰‡ç¼“å­˜</li>
                <li><strong>å†…å­˜æ± ç®¡ç†:</strong> å¯¹è±¡æ± å’Œå­—èŠ‚ç¼“å†²åŒºå¤ç”¨</li>
                <li><strong>å¹¶å‘å®‰å…¨ä¼˜åŒ–:</strong> Lock-freeæ•°æ®ç»“æ„ï¼ŒåŸå­æ“ä½œ</li>
                <li><strong>çƒ­è·¯å¾„ä¼˜åŒ–:</strong> é¢„åˆ†é…ç¼“å†²åŒºï¼Œå­—ç¬¦ä¸²å†…éƒ¨åŒ–</li>
            </ul>
        </div>
    </div>

    <script>
        let currentToken = '';

        async function generateToken() {
            try {
                const response = await fetch('/generate-token');
                const data = await response.json();
                currentToken = data.token;
                
                document.getElementById('token-value').textContent = currentToken;
                document.getElementById('token-display').style.display = 'block';
                
                showResults('âœ… Tokenç”ŸæˆæˆåŠŸ!');
            } catch (error) {
                showResults('âŒ Tokenç”Ÿæˆå¤±è´¥: ' + error.message);
            }
        }

        async function runSingleTest() {
            if (!currentToken) {
                showResults('âŒ è¯·å…ˆç”ŸæˆToken');
                return;
            }

            showResults('æ­£åœ¨è¿è¡Œå•æ¬¡éªŒè¯æµ‹è¯•...');

            try {
                const endpoints = [
                    {name: 'åŸå§‹å®ç°', url: '/benchmark/original'},
                    {name: 'ä¼˜åŒ–ç‰ˆæœ¬', url: '/benchmark/optimized'},
                    {name: 'ä¼ä¸šçº§ä¼˜åŒ–', url: '/benchmark/ultra'}
                ];

                let results = '<strong>å•æ¬¡éªŒè¯æµ‹è¯•ç»“æœ:</strong><br><br>';

                for (const endpoint of endpoints) {
                    const start = performance.now();
                    
                    const response = await fetch(endpoint.url, {
                        headers: {
                            'Authorization': 'Bearer ' + currentToken
                        }
                    });
                    
                    const end = performance.now();
                    const latency = (end - start).toFixed(2);
                    
                    const status = response.ok ? 'âœ…' : 'âŒ';
                    results += endpoint.name + ': ' + status + ' ' + latency + 'ms<br>';
                }

                showResults(results);
            } catch (error) {
                showResults('âŒ æµ‹è¯•å¤±è´¥: ' + error.message);
            }
        }

        async function runBenchmark() {
            if (!currentToken) {
                showResults('âŒ è¯·å…ˆç”ŸæˆToken');
                return;
            }

            showResults('æ­£åœ¨è¿è¡ŒåŸºå‡†æ€§èƒ½æµ‹è¯•...');

            try {
                const response = await fetch('/compare', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        token: currentToken,
                        iterations: 1000
                    })
                });

                const data = await response.json();
                
                let results = '<strong>åŸºå‡†æ€§èƒ½æµ‹è¯•ç»“æœ (1000æ¬¡è¿­ä»£):</strong><br><br>';
                
                for (const [name, result] of Object.entries(data.results)) {
                    const improvement = result.improvement ? ' <span class="improvement">(â†—' + result.improvement.toFixed(1) + '%)</span>' : '';
                    results += name + ': ' + result.avgLatency.toFixed(2) + 'ms' + improvement + '<br>';
                }
                
                results += '<br><strong>æ€»ä½“æ”¹è¿›:</strong> ' + data.totalImprovement.toFixed(1) + '%';

                showResults(results);
            } catch (error) {
                showResults('âŒ åŸºå‡†æµ‹è¯•å¤±è´¥: ' + error.message);
            }
        }

        async function runLoadTest() {
            showResults('æ­£åœ¨è¿è¡Œè´Ÿè½½æµ‹è¯•...');

            try {
                const response = await fetch('/load-test', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        duration: 10,
                        concurrency: 50,
                        qps: 1000
                    })
                });

                const data = await response.json();
                
                let results = '<strong>è´Ÿè½½æµ‹è¯•ç»“æœ (10ç§’, 50å¹¶å‘, 1000 QPS):</strong><br><br>';
                
                for (const [name, result] of Object.entries(data.results)) {
                    results += '<strong>' + name + ':</strong><br>';
                    results += '  QPS: ' + result.qps.toFixed(2) + '<br>';
                    results += '  æˆåŠŸç‡: ' + result.successRate.toFixed(2) + '%<br>';
                    results += '  P95å»¶è¿Ÿ: ' + result.p95Latency + '<br>';
                    results += '<br>';
                }

                showResults(results);
            } catch (error) {
                showResults('âŒ è´Ÿè½½æµ‹è¯•å¤±è´¥: ' + error.message);
            }
        }

        async function refreshMetrics() {
            try {
                const response = await fetch('/metrics');
                const data = await response.json();
                
                let html = '<h3>ğŸ”¥ å®æ—¶æ€§èƒ½æŒ‡æ ‡</h3>';
                
                if (data.ultra) {
                    const ultra = data.ultra;
                    html += '<div class="performance-grid">';
                    html += '<div class="metric ultra">';
                    html += '<div class="metric-label">æ€»è¯·æ±‚æ•°</div>';
                    html += '<div class="metric-value">' + ultra.totalRequests + '</div>';
                    html += '</div>';
                    html += '<div class="metric ultra">';
                    html += '<div class="metric-label">æˆåŠŸç‡</div>';
                    html += '<div class="metric-value">' + ultra.successRate.toFixed(2) + '%</div>';
                    html += '</div>';
                    html += '<div class="metric ultra">';
                    html += '<div class="metric-label">å¹³å‡å»¶è¿Ÿ</div>';
                    html += '<div class="metric-value">' + ultra.avgLatencyMicros.toFixed(2) + 'Î¼s</div>';
                    html += '</div>';
                    html += '<div class="metric ultra">';
                    html += '<div class="metric-label">L1ç¼“å­˜å‘½ä¸­ç‡</div>';
                    html += '<div class="metric-value">' + ultra.l1CacheHitRate.toFixed(2) + '%</div>';
                    html += '</div>';
                    html += '</div>';
                }
                
                document.getElementById('performance-monitor').innerHTML = html;
            } catch (error) {
                document.getElementById('performance-monitor').innerHTML = 'âŒ è·å–æŒ‡æ ‡å¤±è´¥: ' + error.message;
            }
        }

        function showResults(content) {
            document.getElementById('test-results').innerHTML = content;
            document.getElementById('test-results').style.display = 'block';
        }

        // è‡ªåŠ¨åˆ·æ–°æ€§èƒ½æŒ‡æ ‡
        setInterval(refreshMetrics, 10000);
        refreshMetrics();
    </script>
</body>
</html>
    `
	
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte(html))
}

// generateTokenHandler ç”Ÿæˆæµ‹è¯•Tokenå¤„ç†å™¨
func (ds *DemoServer) generateTokenHandler(w http.ResponseWriter, r *http.Request) {
	token, err := jwt.NewJwtToken(ds.jwtSecret, time.Now().Unix(), 3600,
		jwt.WithOption("userId", "demo-user-123"),
		jwt.WithOption("tenantId", "demo-tenant-456"),
		jwt.WithOption("permissions", []string{"read", "write", "admin"}),
		jwt.WithOption("roles", []string{"admin", "user"}))
	
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	
	response := map[string]interface{}{
		"token":     token,
		"expiresAt": time.Now().Add(time.Hour).Unix(),
		"user": map[string]interface{}{
			"userId":   "demo-user-123",
			"tenantId": "demo-tenant-456",
		},
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// comparePerformanceHandler æ€§èƒ½å¯¹æ¯”å¤„ç†å™¨
func (ds *DemoServer) comparePerformanceHandler(w http.ResponseWriter, r *http.Request) {
	var req struct {
		Token      string `json:"token"`
		Iterations int    `json:"iterations"`
	}
	
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	
	if req.Iterations <= 0 {
		req.Iterations = 1000
	}
	
	// æ€§èƒ½æµ‹è¯•
	results := make(map[string]interface{})
	
	// æµ‹è¯•åŸå§‹å®ç°
	originalLatency := ds.benchmarkEndpoint("/benchmark/original", req.Token, req.Iterations)
	results["åŸå§‹å®ç°"] = map[string]interface{}{
		"avgLatency": originalLatency,
	}
	
	// æµ‹è¯•ä¼˜åŒ–ç‰ˆæœ¬
	optimizedLatency := ds.benchmarkEndpoint("/benchmark/optimized", req.Token, req.Iterations)
	improvement1 := (originalLatency - optimizedLatency) / originalLatency * 100
	results["ä¼˜åŒ–ç‰ˆæœ¬"] = map[string]interface{}{
		"avgLatency":  optimizedLatency,
		"improvement": improvement1,
	}
	
	// æµ‹è¯•ä¼ä¸šçº§ä¼˜åŒ–
	ultraLatency := ds.benchmarkEndpoint("/benchmark/ultra", req.Token, req.Iterations)
	improvement2 := (originalLatency - ultraLatency) / originalLatency * 100
	results["ä¼ä¸šçº§ä¼˜åŒ–"] = map[string]interface{}{
		"avgLatency":  ultraLatency,
		"improvement": improvement2,
	}
	
	response := map[string]interface{}{
		"results":           results,
		"totalImprovement":  improvement2,
		"iterations":        req.Iterations,
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// benchmarkEndpoint åŸºå‡†æµ‹è¯•ç«¯ç‚¹
func (ds *DemoServer) benchmarkEndpoint(endpoint, token string, iterations int) float64 {
	var totalDuration time.Duration
	
	for i := 0; i < iterations; i++ {
		start := time.Now()
		
		req, _ := http.NewRequest("GET", "http://localhost:"+strconv.Itoa(ds.port)+endpoint, nil)
		req.Header.Set("Authorization", "Bearer "+token)
		
		client := &http.Client{Timeout: 5 * time.Second}
		resp, err := client.Do(req)
		if err == nil {
			resp.Body.Close()
		}
		
		totalDuration += time.Since(start)
	}
	
	return float64(totalDuration.Nanoseconds()) / float64(iterations) / 1e6 // è½¬æ¢ä¸ºæ¯«ç§’
}

// loadTestHandler è´Ÿè½½æµ‹è¯•å¤„ç†å™¨
func (ds *DemoServer) loadTestHandler(w http.ResponseWriter, r *http.Request) {
	var req struct {
		Duration    int `json:"duration"`
		Concurrency int `json:"concurrency"`
		QPS         int `json:"qps"`
	}
	
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	
	// è®¾ç½®é»˜è®¤å€¼
	if req.Duration <= 0 {
		req.Duration = 10
	}
	if req.Concurrency <= 0 {
		req.Concurrency = 50
	}
	if req.QPS <= 0 {
		req.QPS = 1000
	}
	
	// ç”Ÿæˆæµ‹è¯•Token
	token, _ := jwt.NewJwtToken(ds.jwtSecret, time.Now().Unix(), 7200,
		jwt.WithOption("userId", "load-test-user"),
		jwt.WithOption("tenantId", "load-test-tenant"))
	
	// è´Ÿè½½æµ‹è¯•é…ç½®
	config := &LoadTestConfig{
		Duration:    time.Duration(req.Duration) * time.Second,
		Concurrency: req.Concurrency,
		TokenCount:  100,
		RequestRate: req.QPS,
	}
	
	results := make(map[string]interface{})
	
	// æµ‹è¯•ä¼ä¸šçº§ä¼˜åŒ–ç‰ˆæœ¬
	ultraHandler := http.HandlerFunc(ds.ultraMiddleware.Handle(ds.protectedHandler))
	ultraResult := ds.runSimpleLoadTest(config, ultraHandler, token)
	
	results["ä¼ä¸šçº§ä¼˜åŒ–"] = map[string]interface{}{
		"qps":         ultraResult.QPS,
		"successRate": float64(ultraResult.SuccessRequests) / float64(ultraResult.TotalRequests) * 100,
		"p95Latency":  ultraResult.P95Latency.String(),
		"errorRate":   ultraResult.ErrorRate,
	}
	
	response := map[string]interface{}{
		"results": results,
		"config":  req,
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// runSimpleLoadTest ç®€å•çš„è´Ÿè½½æµ‹è¯•
func (ds *DemoServer) runSimpleLoadTest(config *LoadTestConfig, handler http.Handler, token string) *LoadTestResult {
	result := &LoadTestResult{
		Config:    config,
		StartTime: time.Now(),
	}
	
	// ç®€åŒ–çš„è´Ÿè½½æµ‹è¯•å®ç°
	endTime := time.Now().Add(config.Duration)
	
	for time.Now().Before(endTime) {
		start := time.Now()
		
		req, _ := http.NewRequest("GET", "/test", nil)
		req.Header.Set("Authorization", "Bearer "+token)
		
		w := &mockResponseWriter{}
		handler.ServeHTTP(w, req)
		
		latency := time.Since(start)
		result.TotalRequests++
		result.TotalLatency += int64(latency)
		
		if w.statusCode == 200 {
			result.SuccessRequests++
		} else {
			result.ErrorRequests++
		}
		
		// æ§åˆ¶QPS
		time.Sleep(time.Second / time.Duration(config.RequestRate))
	}
	
	result.EndTime = time.Now()
	actualDuration := result.EndTime.Sub(result.StartTime)
	
	if result.TotalRequests > 0 {
		result.QPS = float64(result.TotalRequests) / actualDuration.Seconds()
		result.ErrorRate = float64(result.ErrorRequests) / float64(result.TotalRequests) * 100
		result.P95Latency = time.Duration(result.TotalLatency/result.TotalRequests) * 95 / 100 // ç®€åŒ–è®¡ç®—
	}
	
	return result
}

// healthHandler å¥åº·æ£€æŸ¥å¤„ç†å™¨
func (ds *DemoServer) healthHandler(w http.ResponseWriter, r *http.Request) {
	health := map[string]interface{}{
		"status":    "healthy",
		"timestamp": time.Now().Unix(),
		"version":   "ultra-performance-v1.0",
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(health)
}

// metricsHandler æŒ‡æ ‡å¤„ç†å™¨
func (ds *DemoServer) metricsHandler(w http.ResponseWriter, r *http.Request) {
	metrics := map[string]interface{}{
		"timestamp": time.Now().Unix(),
	}
	
	// è·å–ä¼ä¸šçº§ä¼˜åŒ–ç‰ˆæœ¬çš„æŒ‡æ ‡
	if ultraMetrics := ds.ultraMiddleware.GetMetrics(); ultraMetrics != nil {
		metrics["ultra"] = ultraMetrics
	}
	
	// è·å–ä¼˜åŒ–ç‰ˆæœ¬çš„æŒ‡æ ‡
	if optimizedMetrics := ds.optimizedMiddleware.GetMetrics(); optimizedMetrics != nil {
		metrics["optimized"] = optimizedMetrics
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(metrics)
}

// protectedHandler å—ä¿æŠ¤çš„å¤„ç†å™¨
func (ds *DemoServer) protectedHandler(w http.ResponseWriter, r *http.Request) {
	// ä»ä¸Šä¸‹æ–‡ä¸­æå–ç”¨æˆ·ä¿¡æ¯
	userID, _ := jwt.ExtractUserIDFast(r.Context())
	tenantID, _ := jwt.ExtractTenantIDFast(r.Context())
	
	response := map[string]interface{}{
		"message":   "è®¤è¯æˆåŠŸ",
		"userID":    userID,
		"tenantID":  tenantID,
		"timestamp": time.Now().Unix(),
	}
	
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// performanceMonitor æ€§èƒ½ç›‘æ§
func (ds *DemoServer) performanceMonitor() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()
	
	for range ticker.C {
		metrics := ds.ultraMiddleware.GetMetrics()
		if metrics != nil {
			log.Printf("ğŸ“Š æ€§èƒ½æŒ‡æ ‡ - æ€»è¯·æ±‚: %d, æˆåŠŸç‡: %.2f%%, L1å‘½ä¸­ç‡: %.2f%%, å¹³å‡å»¶è¿Ÿ: %.2fÎ¼s",
				metrics.TotalRequests,
				metrics.SuccessRate,
				metrics.L1CacheHitRate,
				metrics.AvgLatencyMicros)
		}
	}
}

// mockResponseWriter æ¨¡æ‹Ÿå“åº”å†™å…¥å™¨
type mockResponseWriter struct {
	statusCode int
	headers    http.Header
}

func (m *mockResponseWriter) Header() http.Header {
	if m.headers == nil {
		m.headers = make(http.Header)
	}
	return m.headers
}

func (m *mockResponseWriter) Write([]byte) (int, error) {
	if m.statusCode == 0 {
		m.statusCode = 200
	}
	return 0, nil
}

func (m *mockResponseWriter) WriteHeader(statusCode int) {
	m.statusCode = statusCode
}

// LoadTestConfig è´Ÿè½½æµ‹è¯•é…ç½®
type LoadTestConfig struct {
	Duration    time.Duration
	Concurrency int
	TokenCount  int
	RequestRate int
}

// LoadTestResult è´Ÿè½½æµ‹è¯•ç»“æœ
type LoadTestResult struct {
	Config          *LoadTestConfig
	TotalRequests   int64
	SuccessRequests int64
	ErrorRequests   int64
	TotalLatency    int64
	P95Latency      time.Duration
	QPS             float64
	ErrorRate       float64
	StartTime       time.Time
	EndTime         time.Time
}

func main() {
	port := 8080
	if len(os.Args) > 1 {
		if p, err := strconv.Atoi(os.Args[1]); err == nil {
			port = p
		}
	}
	
	server := NewDemoServer(port)
	
	if err := server.Start(); err != nil && err != http.ErrServerClosed {
		log.Fatalf("æœåŠ¡å™¨å¯åŠ¨å¤±è´¥: %v", err)
	}
}